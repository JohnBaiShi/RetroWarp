#version 450
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_samplerless_texture_functions : require
layout(local_size_x = 8, local_size_y = 8) in;

struct PrimitiveSetup
{
    ivec4 uvzw;
    ivec4 duvzw_dx;
    ivec4 duvzw_dy;

    ivec4 color;
    ivec4 dcolor_dx;
    ivec4 dcolor_dy;

    int x_a, x_b, x_c;
    int dxdy_a, dxdy_b, dxdy_c;
    i16vec2 uv_offset;

    int16_t y_lo, y_mid, y_hi;
    int16_t flags;
};

layout(std430, set = 0, binding = 0) readonly buffer TriangleSetup
{
    PrimitiveSetup primitives[];
};

layout(std430, set = 0, binding = 1) buffer ColorFramebuffer
{
    uint color_data[];
};

layout(std430, set = 0, binding = 2) buffer DepthFramebuffer
{
    uint16_t depth_data[];
};

layout(set = 1, binding = 0) uniform utexture2D uTexture;

layout(std430, push_constant) uniform Registers
{
    uvec2 resolution;
    int primitive_count;
    int fb_stride;
    int scissor_x, scissor_y, scissor_width, scissor_height;
} registers;

#define SUBPIXELS_LOG2 3
#define PRIMITIVE_RIGHT_MAJOR_BIT (1 << 0)
const int raster_rounding = (1 << (SUBPIXELS_LOG2 + 16)) - 1;

int quant_w(int w)
{
    return max((w + 8) >> 4, 1);
}

const int INVERSE_BITS = 4;
const int FIXED_LUT[(1 << INVERSE_BITS) + 1] = int[](
    -8388608,
    -7895160,
    -7456540,
    -7064090,
    -6710886,
    -6391320,
    -6100805,
    -5835553,
    -5592405,
    -5368709,
    -5162220,
    -4971026,
    -4793490,
    -4628197,
    -4473924,
    -4329604,
    -4194304
);

ivec2 fixed_uv_divider(ivec2 uv, int w)
{
    uint uw = uint(w);

    uint leading = 31u - uint(findMSB(uw));
    uw <<= leading;
    uw >>= (31 - INVERSE_BITS - 8);

    int rcp_frac = int(uw & 0xffu);
    uw >>= 8;
    uw &= uint((1 << INVERSE_BITS) - 1);

    int rcp = FIXED_LUT[uw] * (0x100 - rcp_frac) + FIXED_LUT[uw + 1u] * rcp_frac;

    ivec2 lo, hi;
    imulExtended(uv, ivec2(rcp), hi, lo);

    lo = ivec2(uvec2(lo) >> 21);
    hi = hi << 11;
    ivec2 res = -(lo | hi);

    int msb_index = 32 - int(leading);
    res = (res + (1 << (msb_index - 1))) >> msb_index;
    return res;
}

uvec4 filter_linear_horiz(uvec4 left, uvec4 right, uint weight)
{
    uint l = 32u - weight;
    uint r = weight;
    return left * l + right * r;
}

uvec4 filter_linear_vert(uvec4 top, uvec4 bottom, uint weight)
{
    uint t = 32u - weight;
    uint b = weight;
    return (top * t + bottom * b + 512u) >> 10u;
}

uvec4 multiply_unorm8(uvec4 a, uvec4 b)
{
    uvec4 v = a * b;
    v += (v >> 8u);
    v = (v + 0x80u) >> 8u;
    return v;
}

uint clamp_unorm16(int z)
{
    z = (z + 0x80) >> 8;
    return uint(clamp(z, 0, 0xffff));
}

uint pack_color(uvec4 v)
{
    return v.x | (v.y << 8u) | (v.z << 16u) | (v.w << 24u);
}

ivec2 wrap_uv(ivec2 uv)
{
    return (uv << 11) >> 11;
}

void emit_pixel(uvec4 color, uint z, inout uint out_color, inout uint out_z)
{
    if (z < out_z)
    {
        out_color = pack_color(color);
        out_z = z;
    }
}

void main()
{
    uvec2 coord = gl_GlobalInvocationID.xy;
    if (any(greaterThanEqual(coord, registers.resolution)))
        return;

    int x = int(coord.x);
    int y = int(coord.y);
    int y_sub = y << SUBPIXELS_LOG2;

    uint current_color = color_data[y * registers.fb_stride + x];
    uint current_z = uint(depth_data[y * registers.fb_stride + x]);

    int primitive_count = registers.primitive_count;
    for (int i = 0; i < primitive_count; i++)
    {
#define prim primitives[i]
        int interpolation_base_x = prim.x_a >> 16;
        int interpolation_base_y = int(prim.y_lo);

        int span_begin_y = (int(primitives[i].y_lo) + ((1 << SUBPIXELS_LOG2) - 1)) >> SUBPIXELS_LOG2;
        int span_end_y = (int(primitives[i].y_hi) - 1) >> SUBPIXELS_LOG2;

        if (span_begin_y < registers.scissor_y)
            span_begin_y = registers.scissor_y;
        if (span_end_y >= registers.scissor_y + registers.scissor_height)
            span_end_y = registers.scissor_y + registers.scissor_height - 1;

        if (y < span_begin_y || y > span_end_y)
            continue;

        int x_a = prim.x_a + prim.dxdy_a * (y_sub - int(prim.y_lo));
        int x_b = prim.x_b + prim.dxdy_b * (y_sub - int(prim.y_lo));
        int x_c = prim.x_c + prim.dxdy_c * (y_sub - int(prim.y_mid));

        // The secondary span edge is split into two edges.
        bool select_hi = y_sub >= int(prim.y_mid);
        int primary_x = x_a;
        int secondary_x = select_hi ? x_c : x_b;

        int start_x, end_x;

        if ((int(prim.flags) & PRIMITIVE_RIGHT_MAJOR_BIT) != 0)
        {
            start_x = (secondary_x + raster_rounding) >> (16 + SUBPIXELS_LOG2);
            end_x = (primary_x - 1) >> (16 + SUBPIXELS_LOG2);
        }
        else
        {
            start_x = (primary_x + raster_rounding) >> (16 + SUBPIXELS_LOG2);
            end_x = (secondary_x - 1) >> (16 + SUBPIXELS_LOG2);
        }

        if (start_x < registers.scissor_x)
            start_x = registers.scissor_x;
        if (end_x >= registers.scissor_x + registers.scissor_width)
            end_x = registers.scissor_x + registers.scissor_width - 1;

        if (x < start_x || x > end_x)
            continue;

        // We've passed the rasterization test. Interpolate colors, Z, 1/W.
        int dy = y_sub - interpolation_base_y;
        int dx = (x << SUBPIXELS_LOG2) - interpolation_base_x;

        ivec4 rgba = prim.color + prim.dcolor_dx * dx + prim.dcolor_dy * dy;
        uvec4 urgba = uvec4(clamp((rgba + 0x80) >> 8, ivec4(0), ivec4(0xff)));

        ivec4 uvzw = prim.uvzw + prim.duvzw_dx * dx + prim.duvzw_dy * dy;
        ivec2 uv = wrap_uv(uvzw.xy);
        uint z = clamp_unorm16(uvzw.z);
        int w = quant_w(uvzw.w);

        uv = fixed_uv_divider(uv, w);

        uv -= 16;
        ivec2 sub_uv = uv & 31;
        uv >>= 5;

        uv += ivec2(prim.uv_offset);

        uvec4 tex_00 = texelFetch(uTexture, uv, 0);
        uvec4 tex_10 = texelFetchOffset(uTexture, uv, 0, ivec2(1, 0));
        uvec4 tex_01 = texelFetchOffset(uTexture, uv, 0, ivec2(0, 1));
        uvec4 tex_11 = texelFetchOffset(uTexture, uv, 0, ivec2(1, 1));

        uvec4 tex_0 = filter_linear_horiz(tex_00, tex_10, sub_uv.x);
        uvec4 tex_1 = filter_linear_horiz(tex_01, tex_11, sub_uv.x);
        uvec4 tex = filter_linear_vert(tex_0, tex_1, sub_uv.y);

        tex = multiply_unorm8(tex, rgba);
        emit_pixel(tex, z, current_color, current_z);
    }

    color_data[y * registers.fb_stride + x] = current_color;
    depth_data[y * registers.fb_stride + x] = uint16_t(current_z);
}