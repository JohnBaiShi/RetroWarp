#version 450
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_samplerless_texture_functions : require

#if SUBGROUP
#extension GL_KHR_shader_subgroup_shuffle : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_ballot : require
#endif
layout(local_size_x = 256) in;

#include "constants.h"
#include "primitive_setup.h"
#include "fb_info.h"

layout(std430, set = 0, binding = 0) readonly buffer WorkList
{
    u16vec4 tile_raster_work[];
};

struct ColorTile
{
    u8vec4 color[TILE_HEIGHT * TILE_WIDTH];
};

struct DepthTile
{
    uint16_t depth[TILE_HEIGHT * TILE_WIDTH];
};

struct FlagTile
{
    uint16_t flag[TILE_HEIGHT * TILE_WIDTH];
};

layout(std430, set = 0, binding = 1) writeonly buffer Color
{
    ColorTile color_tiles[];
};

layout(std430, set = 0, binding = 2) writeonly buffer Depth
{
    DepthTile depth_tiles[];
};

layout(std430, set = 0, binding = 3) writeonly buffer Flags
{
    FlagTile flag_tiles[];
};

layout(std430, set = 0, binding = 4) readonly buffer TriangleSetupPos
{
    PrimitiveSetupPos primitives_pos[];
};

layout(std430, set = 0, binding = 5) readonly buffer TriangleSetupAttr
{
    PrimitiveSetupAttr primitives_attr[];
};

layout(set = 1, binding = 0) uniform sampler2D uTexture;

int quant_w(int w)
{
    return max((w + 8) >> 4, 1);
}

const int INVERSE_BITS = 4;
const int FIXED_LUT[(1 << INVERSE_BITS) + 1] = int[](
    -8388608,
    -7895160,
    -7456540,
    -7064090,
    -6710886,
    -6391320,
    -6100805,
    -5835553,
    -5592405,
    -5368709,
    -5162220,
    -4971026,
    -4793490,
    -4628197,
    -4473924,
    -4329604,
    -4194304
);

ivec2 fixed_uv_divider(ivec2 uv, int w)
{
    uint uw = uint(w);

    uint leading = 31u - uint(findMSB(uw));
    uw <<= leading;
    uw >>= (31 - INVERSE_BITS - 8);

    int rcp_frac = int(uw & 0xffu);
    uw >>= 8;
    uw &= uint((1 << INVERSE_BITS) - 1);

    int rcp = FIXED_LUT[uw] * (0x100 - rcp_frac) + FIXED_LUT[uw + 1u] * rcp_frac;

    ivec2 lo, hi;
    imulExtended(uv, ivec2(rcp), hi, lo);

    lo = ivec2(uvec2(lo) >> 21);
    hi = hi << 11;
    ivec2 res = -(lo | hi);

    int msb_index = 32 - int(leading);
    res = (res + (1 << (msb_index - 1))) >> msb_index;
    return res;
}

uvec4 filter_linear_horiz(uvec4 left, uvec4 right, uint weight)
{
    uint l = 32u - weight;
    uint r = weight;
    return left * l + right * r;
}

uvec4 filter_linear_vert(uvec4 top, uvec4 bottom, uint weight)
{
    uint t = 32u - weight;
    uint b = weight;
    return (top * t + bottom * b + 512u) >> 10u;
}

uvec4 multiply_unorm8(uvec4 a, uvec4 b)
{
    uvec4 v = a * b;
    v += (v >> 8u);
    v = (v + 0x80u) >> 8u;
    return v;
}

uint clamp_unorm16(int z)
{
    z = (z + 0x80) >> 8;
    return uint(clamp(z, 0, 0xffff));
}

ivec2 wrap_uv(ivec2 uv)
{
    return (uv << 11) >> 11;
}

#if !SUBGROUP
shared float shared_u[gl_WorkGroupSize.x];
shared float shared_v[gl_WorkGroupSize.x];
#endif

void main()
{
    uint work_instance = gl_WorkGroupID.x;
    uvec4 work_item = uvec4(tile_raster_work[work_instance]);

    uint tile_x = work_item.x;
    uint tile_y = work_item.y;
    uint tile_instance_index = work_item.z;
    uint primitive_index = work_item.w;

#if SUBGROUP
    uint local_index = gl_SubgroupInvocationID + gl_SubgroupID * gl_SubgroupSize;
#else
    uint local_index = gl_LocalInvocationIndex;
#endif

    uint quad_index = local_index >> 2u;
    uint quad_x = quad_index & 7u;
    uint quad_y = (quad_index >> 3u) & 7u;

    uint local_x = quad_x * 2u + (local_index & 1u);
    uint local_y = quad_y * 2u + ((local_index >> 1u) & 1u);
    uint local_pixel = local_x + local_y * TILE_WIDTH;

    int x = int(tile_x * uint(TILE_WIDTH) + local_x);
    int y = int(tile_y * uint(TILE_HEIGHT) + local_y);

    int y_sub = y << SUBPIXELS_LOG2;

#define prim_pos primitives_pos[primitive_index]
#define prim_attr primitives_attr[primitive_index]

    int interpolation_base_x = prim_pos.x_a >> 16;
    int interpolation_base_y = int(prim_pos.y_lo);

    int span_begin_y = (int(prim_pos.y_lo) + ((1 << SUBPIXELS_LOG2) - 1)) >> SUBPIXELS_LOG2;
    int span_end_y = (int(prim_pos.y_hi) - 1) >> SUBPIXELS_LOG2;

    if (span_begin_y < fb_info.scissor.y)
        span_begin_y = fb_info.scissor.y;
    if (span_end_y >= fb_info.scissor.y + fb_info.scissor.w)
        span_end_y = fb_info.scissor.y + fb_info.scissor.w - 1;

    // Need to compute UV for derivatives.
    float dx = float((x << SUBPIXELS_LOG2) - interpolation_base_x);
    float dy = float(y_sub - interpolation_base_y);

    float j = prim_attr.djdx * dx + prim_attr.djdy * dy;
    float k = prim_attr.dkdx * dx + prim_attr.dkdy * dy;
    float i = 1.0 - j - k;
    vec3 bary = vec3(i, j, k);

    float u = dot(prim_attr.u, bary);
    float v = dot(prim_attr.v, bary);
    float w = dot(prim_attr.w, bary);
    w = max(w, 0.00001);
    vec2 f_uv = vec2(u, v) / w;

#if SUBGROUP
    vec2 f_uv_horiz = subgroupShuffleXor(f_uv, 1);
    vec2 f_uv_vert = subgroupShuffleXor(f_uv, 2);
#else
    shared_u[local_index] = f_uv.x;
    shared_v[local_index] = f_uv.y;
    barrier();
#endif

    if (y < span_begin_y || y > span_end_y)
    {
        flag_tiles[tile_instance_index].flag[local_pixel] = uint16_t(0);
        return;
    }

    int x_a = prim_pos.x_a + prim_pos.dxdy_a * (y_sub - int(prim_pos.y_lo));
    int x_b = prim_pos.x_b + prim_pos.dxdy_b * (y_sub - int(prim_pos.y_lo));
    int x_c = prim_pos.x_c + prim_pos.dxdy_c * (y_sub - int(prim_pos.y_mid));

    // The secondary span edge is split into two edges.
    bool select_hi = y_sub >= int(prim_pos.y_mid);
    int primary_x = x_a;
    int secondary_x = select_hi ? x_c : x_b;

    int start_x, end_x;

    if ((int(prim_pos.flags) & PRIMITIVE_RIGHT_MAJOR_BIT) != 0)
    {
        start_x = (secondary_x + RASTER_ROUNDING) >> (16 + SUBPIXELS_LOG2);
        end_x = (primary_x - 1) >> (16 + SUBPIXELS_LOG2);
    }
    else
    {
        start_x = (primary_x + RASTER_ROUNDING) >> (16 + SUBPIXELS_LOG2);
        end_x = (secondary_x - 1) >> (16 + SUBPIXELS_LOG2);
    }

    if (start_x < fb_info.scissor.x)
        start_x = fb_info.scissor.x;
    if (end_x >= fb_info.scissor.x + fb_info.scissor.z)
        end_x = fb_info.scissor.x + fb_info.scissor.z - 1;

    if (x < start_x || x > end_x)
    {
        flag_tiles[tile_instance_index].flag[local_pixel] = uint16_t(0);
        return;
    }

    // We've passed the rasterization test. Interpolate colors, Z, 1/W.
    uint z = uint(clamp(round(float(0xffff) * (prim_attr.z + prim_attr.dzdx * dx + prim_attr.dzdy * dy)), 0.0, float(0xffff)));

    vec4 rgba =
        vec4(uvec4(prim_attr.color_a)) * i +
        vec4(uvec4(prim_attr.color_b)) * j +
        vec4(uvec4(prim_attr.color_c)) * k;

    uvec4 urgba = uvec4(clamp(round(rgba), vec4(0.0), vec4(255.0)));

    ivec2 uv = ivec2(round(f_uv * 32.0));

#if SUBGROUP
    float dudx = abs(f_uv_horiz.x - f_uv.x);
    float dudy = abs(f_uv_vert.x - f_uv.x);
    float dvdx = abs(f_uv_horiz.y - f_uv.y);
    float dvdy = abs(f_uv_vert.y - f_uv.y);
#else
    float dudx = abs(shared_u[local_index ^ 1u] - f_uv.x);
    float dudy = abs(shared_u[local_index ^ 2u] - f_uv.x);
    float dvdx = abs(shared_v[local_index ^ 1u] - f_uv.y);
    float dvdy = abs(shared_v[local_index ^ 2u] - f_uv.y);
#endif

    float f_width = max(dudx + dudy, dudx + dudy);
    f_width = max(f_width, 1.0);
    float f_lod = log2(f_width);

    //uv -= 16;
    //ivec2 sub_uv = uv & 31;
    //uv >>= 5;
    uv += 32 * ivec2(prim_attr.uv_offset);

    f_uv = vec2(uv) / (32.0 * textureSize(uTexture, 0).xy);
    uvec4 tex = uvec4(255.0 * textureLod(uTexture, f_uv, f_lod));
    if (tex.w < 128u)
    {
        flag_tiles[tile_instance_index].flag[local_pixel] = uint16_t(0);
        return;
    }
    //tex = uvec4(30.0 * f_lod);
#if 0
    uvec4 tex_10 = texelFetchOffset(uTexture, uv, 0, ivec2(1, 0));
    uvec4 tex_01 = texelFetchOffset(uTexture, uv, 0, ivec2(0, 1));
    uvec4 tex_11 = texelFetchOffset(uTexture, uv, 0, ivec2(1, 1));

    uvec4 tex_0 = filter_linear_horiz(tex_00, tex_10, sub_uv.x);
    uvec4 tex_1 = filter_linear_horiz(tex_01, tex_11, sub_uv.x);
    uvec4 tex = filter_linear_vert(tex_0, tex_1, sub_uv.y);
#endif

    tex = multiply_unorm8(tex, urgba);

    color_tiles[tile_instance_index].color[local_pixel] = u8vec4(tex);
    depth_tiles[tile_instance_index].depth[local_pixel] = uint16_t(z);
    flag_tiles[tile_instance_index].flag[local_pixel] = uint16_t(1);
}
