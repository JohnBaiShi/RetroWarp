#version 450
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_samplerless_texture_functions : require

#ifdef DERIVATIVE_GROUP_LINEAR
#extension GL_NV_compute_shader_derivatives : require
layout(derivative_group_linearNV, local_size_x = 256) in;
#elif SUBGROUP
#extension GL_KHR_shader_subgroup_shuffle : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_ballot : require
layout(local_size_x = 256) in;
#else
layout(local_size_x = 256) in;
#endif

#define PRIMITIVE_SETUP_POS_BUFFER 4
#define PRIMITIVE_SETUP_ATTR_BUFFER 5
#include "rasterizer_helpers.h"

struct TileRasterWork
{
   uint16_t x, y, instance, prim;
};

layout(std430, set = 0, binding = 0) readonly buffer WorkList
{
    TileRasterWork tile_raster_work[];
};

struct ColorTile
{
    u8vec4 color[TILE_HEIGHT * TILE_WIDTH];
};

struct DepthTile
{
    uint16_t depth[TILE_HEIGHT * TILE_WIDTH];
};

struct FlagTile
{
    uint8_t flag[TILE_HEIGHT * TILE_WIDTH];
};

layout(std430, set = 0, binding = 1) writeonly buffer Color
{
    ColorTile color_tiles[];
};

layout(std430, set = 0, binding = 2) writeonly buffer Depth
{
    DepthTile depth_tiles[];
};

layout(std430, set = 0, binding = 3) writeonly buffer Flags
{
    FlagTile flag_tiles[];
};

layout(set = 1, binding = 0) uniform sampler2D uTexture;

#if 0
int quant_w(int w)
{
    return max((w + 8) >> 4, 1);
}

const int INVERSE_BITS = 4;
const int FIXED_LUT[(1 << INVERSE_BITS) + 1] = int[](
    -8388608,
    -7895160,
    -7456540,
    -7064090,
    -6710886,
    -6391320,
    -6100805,
    -5835553,
    -5592405,
    -5368709,
    -5162220,
    -4971026,
    -4793490,
    -4628197,
    -4473924,
    -4329604,
    -4194304
);

ivec2 fixed_uv_divider(ivec2 uv, int w)
{
    uint uw = uint(w);

    uint leading = 31u - uint(findMSB(uw));
    uw <<= leading;
    uw >>= (31 - INVERSE_BITS - 8);

    int rcp_frac = int(uw & 0xffu);
    uw >>= 8;
    uw &= uint((1 << INVERSE_BITS) - 1);

    int rcp = FIXED_LUT[uw] * (0x100 - rcp_frac) + FIXED_LUT[uw + 1u] * rcp_frac;

    ivec2 lo, hi;
    imulExtended(uv, ivec2(rcp), hi, lo);

    lo = ivec2(uvec2(lo) >> 21);
    hi = hi << 11;
    ivec2 res = -(lo | hi);

    int msb_index = 32 - int(leading);
    res = (res + (1 << (msb_index - 1))) >> msb_index;
    return res;
}

uvec4 filter_linear_horiz(uvec4 left, uvec4 right, uint weight)
{
    uint l = 32u - weight;
    uint r = weight;
    return left * l + right * r;
}

uvec4 filter_linear_vert(uvec4 top, uvec4 bottom, uint weight)
{
    uint t = 32u - weight;
    uint b = weight;
    return (top * t + bottom * b + 512u) >> 10u;
}

uint clamp_unorm16(int z)
{
    z = (z + 0x80) >> 8;
    return uint(clamp(z, 0, 0xffff));
}

ivec2 wrap_uv(ivec2 uv)
{
    return (uv << 11) >> 11;
}

uvec4 multiply_unorm8(uvec4 a, uvec4 b)
{
    uvec4 v = a * b;
    v += (v >> 8u);
    v = (v + 0x80u) >> 8u;
    return v;
}
#endif

#if !SUBGROUP && !defined(DERIVATIVE_GROUP_LINEAR)
shared float shared_u[gl_WorkGroupSize.x];
shared float shared_v[gl_WorkGroupSize.x];
#endif

void main()
{
    uint work_instance = gl_WorkGroupID.x;

    uint tile_x = uint(tile_raster_work[work_instance].x);
    uint tile_y = uint(tile_raster_work[work_instance].y);
    uint tile_instance_index = uint(tile_raster_work[work_instance].instance);
    uint primitive_index = uint(tile_raster_work[work_instance].prim);

#ifdef DERIVATIVE_GROUP_LINEAR
    uint local_index = gl_LocalInvocationIndex;
#elif SUBGROUP
    uint local_index = gl_SubgroupInvocationID + gl_SubgroupID * gl_SubgroupSize;
#else
    uint local_index = gl_LocalInvocationIndex;
#endif

    uint quad_index = local_index >> 2u;
    uint quad_x = quad_index & 7u;
    uint quad_y = (quad_index >> 3u) & 7u;

    uint local_x = quad_x * 2u + (local_index & 1u);
    uint local_y = quad_y * 2u + ((local_index >> 1u) & 1u);
    uint local_pixel = local_x + local_y * TILE_WIDTH;

    int x = int(tile_x * uint(TILE_WIDTH) + local_x);
    int y = int(tile_y * uint(TILE_HEIGHT) + local_y);

    ivec2 interpolation_base = get_interpolation_base(primitive_index);
    vec3 bary = interpolate_barycentrics(primitive_index, x, y, interpolation_base);
    vec2 f_uv = interpolate_uv(primitive_index, bary);

#ifdef DERIVATIVE_GROUP_LINEAR
    vec2 f_width2 = fwidth(f_uv);
    float f_width = max(f_width2.x, f_width2.y);
#elif SUBGROUP
    vec2 f_uv_horiz = subgroupShuffleXor(f_uv, 1);
    vec2 f_uv_vert = subgroupShuffleXor(f_uv, 2);
#else
    shared_u[local_index] = f_uv.x;
    shared_v[local_index] = f_uv.y;
    barrier();
#endif

    bool has_coverage = test_coverage_single(primitive_index, x, y);
    if (!has_coverage)
    {
        flag_tiles[tile_instance_index].flag[local_pixel] = uint8_t(0);
        return;
    }

    // We've passed the rasterization test. Interpolate colors, Z, 1/W.
    vec4 rgba = interpolate_rgba(primitive_index, bary);

#if SUBGROUP
    float dudx = abs(f_uv_horiz.x - f_uv.x);
    float dudy = abs(f_uv_vert.x - f_uv.x);
    float dvdx = abs(f_uv_horiz.y - f_uv.y);
    float dvdy = abs(f_uv_vert.y - f_uv.y);
    float f_width = max(dudx + dudy, dudx + dudy);
#elif !defined(DERIVATIVE_GROUP_LINEAR)
    float dudx = abs(shared_u[local_index ^ 1u] - f_uv.x);
    float dudy = abs(shared_u[local_index ^ 2u] - f_uv.x);
    float dvdx = abs(shared_v[local_index ^ 1u] - f_uv.y);
    float dvdy = abs(shared_v[local_index ^ 2u] - f_uv.y);
    float f_width = max(dudx + dudy, dudx + dudy);
#endif

    f_width = max(f_width, 1.0);
    float f_lod = log2(f_width);
    f_uv /= textureSize(uTexture, 0).xy;

    vec4 tex = textureLod(uTexture, f_uv, f_lod);
    if (tex.w < 0.5)
    {
        flag_tiles[tile_instance_index].flag[local_pixel] = uint8_t(0);
        return;
    }

    rgba *= tex;
    uint z = interpolate_z(primitive_index, x, y, interpolation_base);

    uvec4 urgba = uvec4(round(rgba));
    color_tiles[tile_instance_index].color[local_pixel] = u8vec4(urgba);
    depth_tiles[tile_instance_index].depth[local_pixel] = uint16_t(z);
    flag_tiles[tile_instance_index].flag[local_pixel] = uint8_t(1);
}
