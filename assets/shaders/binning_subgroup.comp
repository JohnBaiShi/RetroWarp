#version 450
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_8bit_storage : require

#if SUBGROUP
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_ballot : require
layout(local_size_x_id = 0) in;
#else
layout(local_size_x = 32) in;
#endif

#include "primitive_setup.h"
#include "constants.h"
#include "fb_info.h"

layout(std430, set = 0, binding = 0) writeonly buffer TileBitmask
{
    uint binned_bitmask[];
};

layout(std430, set = 0, binding = 1) readonly buffer TriangleSetupPos
{
    PrimitiveSetupPos primitives_pos[];
};

layout(std430, set = 0, binding = 2) readonly buffer TileBitmaskLowRes
{
    uint binned_bitmask_low_res[];
};

layout(std430, set = 0, binding = 3) writeonly buffer TileBitmaskCoarse
{
    uint binned_bitmask_coarse[];
};

#if !SUBGROUP
shared uint merged_mask;
#endif

#define prim primitives_pos[index]
ivec2 interpolate_x(int index, int y_sub)
{
    int x_a = prim.x_a + prim.dxdy_a * (y_sub - int(prim.y_lo));
    int x_b = prim.x_b + prim.dxdy_b * (y_sub - int(prim.y_lo));
    int x_c = prim.x_c + prim.dxdy_c * (y_sub - int(prim.y_mid));

    bool select_hi = y_sub >= int(prim.y_mid);
    int primary_x = x_a;
    int secondary_x = select_hi ? x_c : x_b;
    return ivec2(primary_x, secondary_x);
}

int min2x2(ivec2 a, ivec2 b)
{
    ivec2 c = min(a, b);
    return min(c.x, c.y);
}

int max2x2(ivec2 a, ivec2 b)
{
    ivec2 c = max(a, b);
    return max(c.x, c.y);
}

int min2(ivec2 a)
{
    return min(a.x, a.y);
}

int max2(ivec2 a)
{
    return max(a.x, a.y);
}

bool bin_primitive(ivec2 start, ivec2 end, int index)
{
    int start_y = start.y << SUBPIXELS_LOG2;
    int end_y = (end.y << SUBPIXELS_LOG2) - 1;
    // First, we clip start/end against y_lo, y_hi.
    start_y = max(start_y, int(prim.y_lo));
    end_y = min(end_y, int(prim.y_hi) - 1);

    // Y is clipped out, exit early.
    if (end_y < start_y)
        return false;

    // Evaluate span ranges at Y = start.y, Y = end.y, and Y = y_mid (if y_mid falls within the span range).
    ivec2 x_lo = interpolate_x(index, start_y);
    ivec2 x_hi = interpolate_x(index, end_y);
    int lo_x = min2x2(x_lo, x_hi);
    int hi_x = max2x2(x_lo, x_hi);
    int y_mid = int(prim.y_mid);
    if (y_mid > start_y && y_mid < end_y)
    {
        ivec2 x_mid = interpolate_x(index, y_mid);
        lo_x = min(lo_x, min2(x_mid));
        hi_x = max(hi_x, max2(x_mid));
    }

    // Snap min/max to grid.
    int start_x = (lo_x + RASTER_ROUNDING) >> (16 + SUBPIXELS_LOG2);
    int end_x = (hi_x - 1) >> (16 + SUBPIXELS_LOG2);

    // Clip start/end against raster region.
    start_x = max(start_x, start.x);
    end_x = min(end_x, end.x);

    // If start_x <= end_x we will need to rasterize something.
    return start_x <= end_x;
}
#undef prim

void main()
{
    ivec2 tile = ivec2(gl_WorkGroupID.yz);
    ivec2 base_coord = tile * ivec2(TILE_WIDTH, TILE_HEIGHT);
    ivec2 end_coord = min(base_coord + ivec2(TILE_WIDTH, TILE_HEIGHT), ivec2(fb_info.resolution));

    int mask_index = int(gl_GlobalInvocationID.x);
    int linear_tile = tile.y * MAX_TILES_X + tile.x;
    uint local_index = gl_SubgroupInvocationID;

    bool group_bin_to_tile = false;
    if (mask_index < fb_info.primitive_count_32)
    {
        int linear_tile_lowres = (tile.y >> 2) * MAX_TILES_X_LOW_RES + (tile.x >> 2);
        int binned_bitmask_offset = linear_tile_lowres * TILE_BINNING_STRIDE + mask_index;

        uint low_res_binned = binned_bitmask_low_res[binned_bitmask_offset];
        uint binned = 0u;
        while (low_res_binned != 0u)
        {
            int i = findLSB(low_res_binned);
            low_res_binned &= ~uint(1 << i);

            int primitive_index = i + mask_index * 32;
            if (bin_primitive(base_coord, end_coord, primitive_index))
                binned |= 1u << uint(i);
        }

        binned_bitmask[linear_tile * TILE_BINNING_STRIDE + mask_index] = binned;
        group_bin_to_tile = binned != 0u;
    }

#if SUBGROUP
    uvec4 ballot_result = subgroupBallot(group_bin_to_tile);
    if (subgroupElect())
    {
        uint binned_bitmask_offset = uint(TILE_BINNING_STRIDE_COARSE * linear_tile);
        if (gl_SubgroupSize == 64u)
        {
            binned_bitmask_coarse[binned_bitmask_offset + 2u * gl_WorkGroupID.x] = ballot_result.x;
            binned_bitmask_coarse[binned_bitmask_offset + 2u * gl_WorkGroupID.x + 1u] = ballot_result.y;
        }
        else if (gl_SubgroupSize == 32u)
        {
            binned_bitmask_coarse[binned_bitmask_offset + gl_WorkGroupID.x] = ballot_result.x;
        }
    }
#else
    if (local_index == 0u)
        merged_mask = 0u;
    barrier();

    if (group_bin_to_tile)
        atomicOr(merged_mask, 1u << local_index);

    barrier();

    if (local_index == 0u)
    {
        uint binned_bitmask_offset = uint(TILE_BINNING_STRIDE_COARSE * linear_tile);
        binned_bitmask_coarse[binned_bitmask_offset + gl_WorkGroupID.x] = merged_mask;
    }
#endif
}