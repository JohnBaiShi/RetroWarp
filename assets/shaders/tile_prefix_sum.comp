#version 450
#extension GL_EXT_shader_16bit_storage : require

#if SUBGROUP
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_basic : require
layout(local_size_x_id = 0) in;
#else
layout(local_size_x = 32) in;
#endif

#include "constants.h"
#include "fb_info.h"

layout(std430, set = 0, binding = 0) readonly buffer MaskBuffer
{
    uint mask_buffer[];
};

layout(std430, set = 0, binding = 1) writeonly buffer TilePrefixSum
{
    uint16_t tile_prefix_sums[];
};

layout(std430, set = 0, binding = 2) writeonly buffer TileTotals
{
    uint16_t tile_sums[];
};

#if !SUBGROUP
shared uint shared_counts[gl_WorkGroupSize.x];
#endif

void main()
{
    ivec2 tile = ivec2(gl_WorkGroupID.xy);
    int linear_tile = tile.x + tile.y * MAX_TILES_X;
    int base_offset = linear_tile * TILE_BINNING_STRIDE;

    uint num_masks = uint(fb_info.primitive_count_32);
    uint total_primitives = 0u;

#if SUBGROUP
    uint local_index = gl_SubgroupInvocationID;
    for (uint i = 0u; i < num_masks; i += gl_WorkGroupSize.x)
    {
        uint bit_count = 0u;
        uint mask_index = i + local_index;
        if (mask_index < num_masks)
        {
            uint count = mask_buffer[mask_index + base_offset];
            bit_count = uint(bitCount(count));
        }

        // subgroupExclusiveAdd is broken on current RADV + Navi.
        uint scan_result = total_primitives + subgroupInclusiveAdd(bit_count) - bit_count;
        if (mask_index < num_masks)
            tile_prefix_sums[mask_index + base_offset] = uint16_t(scan_result);

        // Could just broadcast last element of InclusiveAdd, but the ID has to be a compile time constant <___<.
        total_primitives += subgroupAdd(bit_count);
    }
    if (subgroupElect())
        tile_sums[linear_tile] = uint16_t(total_primitives);
#else
    uint local_index = gl_LocalInvocationIndex;
    for (uint i = 0u; i < num_masks; i += gl_WorkGroupSize.x)
    {
        uint bit_count_orig = 0u;
        uint mask_index = i + local_index;
        if (mask_index < num_masks)
            bit_count_orig = uint(bitCount(mask_buffer[mask_index + base_offset]));

        uint bit_count = bit_count_orig;
        shared_counts[local_index] = bit_count;
        barrier();

        for (uint step = 2u; step <= gl_WorkGroupSize.x; step <<= 1u)
        {
            uint mask = step - 1u;
            uint inv_mask = ~mask;
            uint local_index_masked = local_index & mask;
            uint local_index_inv_masked = local_index & inv_mask;
            mask >>= 1u;
            if (local_index_masked > mask)
            {
                uint src_index = local_index_inv_masked + mask;
                bit_count += shared_counts[src_index];
                shared_counts[local_index] = bit_count;
            }
            barrier();
        }

        if (mask_index < num_masks)
            tile_prefix_sums[mask_index + base_offset] = uint16_t(total_primitives + bit_count - bit_count_orig);
        total_primitives += shared_counts[gl_WorkGroupSize.x - 1u];

        barrier();
    }

    if (local_index == 0u)
        tile_sums[linear_tile] = uint16_t(total_primitives);
#endif
}
